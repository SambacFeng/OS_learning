# 操作系统概念
### 第一章 导论
操作系统(operating system)是管理计算机硬件的**程序**，为应用程序提供**基础**，并且充当计算机用户和计算机硬件的**中介(intermediary)**
1. 操作系统的功能
   1. 计算机系统
      1. 硬件(hardware)为系统提供基本的计算资源
         1. 中央处理单元 CPU
         2. 内存 memory
         3. 输入输出设备 I/O device
      2. 操作系统调度不同用户和应用对硬件资源的使用，是一直运行在计算机上的程序，通常称为**内核(kernel)**，除内核外还有系统程序和应用程序两类程序
      3. 应用程序(application program)规定了用户为解决计算问题而使用这些资源的方式
      4. 用户(user)包括人、机器、其他计算机
2. 计算机系统的组成  
   1. 引导程序(bootstrap program)位于固件(firmware)如只读内存(read-only memory, ROM)或电可擦可编程只读内存(electrically erasable programmable memory， EEPROM)  
   系统程序在启动时加载到内存成为系统进程或系统后台程序(system daemon)
   2. 存储结构  
   CPU只能从内存(main memory)也称为随机访问内存(random access memory, RAM)中加载指令，内存通常为动态随机访问内存(dynamic random access memory, DRAM)，内存是易失性(volatile)的，掉电时就会失去所有内容  
   因此提供外存(secondary storage)如磁盘或硬盘(magnetic disk)来永久储存大量数据  
   存储设备的层次：寄存器 高速缓存 内存 固态磁盘 硬盘 光盘 磁带  
   固态磁盘以上为易失存储
   基本存储单元是位(bit)，一个字节(byte)是8位
   3. 缓存(cache)在计算机中有多级，使用中的缓存被从较慢存储中复制到更快的存储中，调用时首先从较快缓存中使用信息
3. 计算机系统的体系结构  
   多处理器环境必须在硬件中提供缓存连贯性(cache coherency)以便所有CPU在其缓存中都有最新值  
   多核系统为多处理器系统，但并不是所有多处理器系统都是多核的
4. 操作系统的结构  
   多道程序设计(multiprogramming)提高了CPU利用率，分时系统(time sharing)(或多任务(multitasking))是多道程序设计的自然延伸
5. 操作系统的执行  
   现代操作系统是**中断驱动**(interrupt driven)的  
   为了确保操作系统正确运行至少需要两种单独运行模式：用户模式和内核模式，执行用户应用时处于用户模式，用户应用通过系统调用请求操作系统服务时切换到内核模式(陷入内核)双重模式执行提供保护手段以便防止操作系统和用户程序受到错误用户程序的影响
6. 进程管理  
   **执行的程序(program)称为进程(process)**，程序本身不是进程，程序适个被动实体，如同存储在磁盘上的文件内容，而进程是个主动实体。进程需要如CPU、内存这样的资源完成其任务，进程在终止时需回收任何可重复利用的资源  
   单线程进程有一个程序计数器(program counter, PC)指定了下一个所要执行的指令，进程按顺序、一次一个地执行指令直到完成，多线程进程的每个线程都有一个程序计数器。  
   一个典型的系统一般有许多进程、一些用户，一些操作系统同时在一个或多个CPU上同时运行  
   操作系统负责：  
   1. 在CPU上调度进程和线程
   2. 创建和删除用户进程和系统进程
   3. 挂起和重启进程
   4. 提供进程同步机制
   5. 提供进程通信机制
7. 内存管理  
   要执行程序，指令和数据的所有或部分必须在内存中  
   操作系统负责内存管理的：
   1. 记录内存的哪部分在被使用以及被谁使用
   2. 决定哪些进程(或部分)会调入或调出内存
   3. 根据需要分配和释放内存空间
8. 存储管理  
   操作系统提供信息存储的统一逻辑视图，对存储设备的物理属性进行了抽象，并定义了逻辑存储单元，即文件(file)  
   1. 文件系统管理  
   文件可组织成目录、控制哪个用户如何访问文件等  
   操作系统负责文件管理的：  
      1. 创建和删除文件
      2. 创建和删除目录以便组织文件
      3. 提供文件和目录的操作原语
      4. 映射文件到外存
      5. 备份文件到稳定(非易失的)存储介质
   2. 大容量存储器管理  

### 第二章 操作系统结构  
多道程序设计和分时  
系统引导  
系统设备  
**系统调用**：用户模式和内核模式  
系统设计、实现、结构和debug  
多道程序设计提高了效率，因为单用户无法保持CPU和IO设备始终繁忙，当一个进程在等待时切换到另一个进程  
分时是对CPU任务切换的逻辑扩展，以保证在CPU对任务进行切换时，用户能与所需程序进行交互，应保持<1ms的响应时间  
UNIX time：从1970.1.1 00：00：00到现在所流逝的秒数  
jiffies：自系统启动所经历的中断次数  
无论何时，单个CPU上总有一个活动任务
BIOS/UEFI, POST(power-on self-test), MBR/GUID, Grub  
CLI允许直接键入命令进行操作，有时在内核中进行，有些在系统程序中实现  
现在许多系统同时具有CLI和GUI  
双模式(dual-mode)使操作系统得以保护自身和其他系统组件，分为用户模式和内核模式，模式位(mode bit)由硬件提供，提供区分运行用户代码或内核代码的能力，部分需要权限的指令仅能在内核模式下执行  
在用户进程执行时，进行系统调用后会陷入(trap)内核，系统调用在执行后返回用户进程  
操作系统提供的服务一般由高级语言编写，通过高级应用程序编程接口(Application Programming Interface, API)来访问程序，而不是直接进行系统调用  
中断驱动：硬件中断通过某个设备，软件中断通过异常或捕获，如软件错误、操作系统服务请求、无限循环，进程相互修改或操作系统等





### 第五章 进程调度
多CPU  
多核  
超线程技术(Hyper Threading, HT)：单个CPU核心具有两个线程，可执行不同指令  
非对称多处理:一核调度，多核干活
对称多处理：(Symmetric multiprocessing, SMP)：每个核心自己调度自己的工作  
Linux中每个逻辑CPU拥有一个调度队列  
处理器亲和性(Processor Affinity)：多CPU间调度时避免单个进程从一个处理器迁移到另一个处理器，软亲和性：试图保持，硬亲和性：通过绑定强制保持。Linux实现软亲和性，但也可以实现硬亲和性  
负载平衡(Load Balancing)：保持所有CPU上工作负载均分分布。推和拉两种形式，一个被动一个主动，增加了效率但抵消了处理器亲和力的好处  
线程调度：内核级线程被操作系统所调度，用户级线程为了运行在CPU上要映射到相关的内核级线程(可能采取轻量级进程(LWP))。用户级线程进行进程竞争范围(process-contention scope, PCS)，发生在同一进程的线程之间。为了决定哪个内核级线程调度到一个处理器上，内核采用系统竞争范围(system-contention scope, SCS)。PCS优先级通常由程序员设置。

### 第六章 同步  
临界区：可能修改公共变量  
临界区解决要求：
1. 互斥：临界区进程数量不大于1
2. 空闲让进：临界区内无进程，有进程需要进入临界区
3. 有限等待
软件解决：Peterson方案

互斥锁(mutex lock) 同步(synchronization) 信号量(Semaphore)  

### 第七章 死锁
1. 系统模型
   1. 系统由资源组成
   2. 资源类型R123...m
   3. type R 有Wi实例
   4. 进程对资源有请求使用释放等

2. 死锁  
   1. 死锁是永久性的，不能从内部被打破
   2. 产生时的现象(四个必要条件)
      1. 互斥：资源互斥访问
      2. 持有和等待：每一个进程都持有一部分资源，请求另一部分资源
      3. 非抢占(条件式抢占)
      4. 循环等待
   3. 总结：
      1. 无环无死锁
      2. 有环：每个类型的资源仅有一实例则死锁

3. 死锁的解决
   1. 检测和恢复：对于仅有单实例的资源因有环而死锁：创建等待图(wait-for graph)
4. 总结  

### 第八章 内存管理策略  
1. 背景